	.nolist
#include "ti83plus.inc"
#include "app.inc"
#include "variables.inc"		; variables saved in saferam
#include "settings.inc"			; contains constants

#macro cp_hl_de()
	or a
	sbc hl,de
	add hl,de
#endmacro
	.list
defpage(0, "PokeMono")

	di

; SETUP
	ld hl,INSERT_RAM			;
	bcall(_EnoughMem)			; check if we have enough RAM
	 jr nc,$+5					; if we do, great!
		bjump(_JForceCmdNoChar) ; otherwise, ciao!
	ex de,hl					; hl = amount of RAM to insert (EnoughMem returns amount of RAM in de)
	ld de,$9D95					; de = where to insert the RAM
	bcall(_InsertMem)			; insert the memory

	ld h,d
	ld l,e
	inc de
	ld (hl),0
	ld bc,INSERT_RAM-1
	ldir						; probably not really necessary, but set it all to 0

	ld hl,saferam3
	ld de,saferam3+1
	ld (hl),0
	ld bc,127
	ldir

	ld hl,$0202
	ld (player_y),hl			; update player_y and player_x

	ld a,(contrast)
	ld (contrast_var),a
	set textWrite,(IY+sGrFlags)
	res textEraseBelow,(IY+textFlags)

	call start

	ld de,INSERT_RAM
	ld hl,$9D95
	bcall(_DelMem)				; delete the RAM we've inserted before quitting (no RAM leaks!)
	bjump(_JForceCmdNoChar) 	; ciao !
;####### end of program #########

start:
	call fade_out				; [routines.inc]
	bcall(_GrBufClr)
	xor a
	ld b,a
	ld c,a
	call load_map				; load map 0, coords 0,0 [engine.inc]
	call draw_map				; [engine.inc]
	call draw_player			; [engine.inc]
	call fastCopy				; [routines.inc]
	call clear_player			; [engine.inc]
	call fade_in				; [routines.inc]
main_loop:
	call draw_map				; [engine.inc]
	call draw_player			; [engine.inc]
	call fastCopy				; [routines.inc]

	ld a,$BF					; group 7
	call get_key				; contains: [2nd][Mode][Del],[Y=]->[Graph]
	bit 4,a						; was [Y=] pressed?
	 call z,menu_start			; then run the menu [menu.inc]

	call clear_player			; remove player from map (for scrolling purposes) [engine.inc]

	ld a,$FD					; group 2
	call get_key				; [Enter]->[Clear]
	bit 6,a						; was [Clear] pressed?
	 ret z						; if so, exit

	ld hl,walk_anim				; move to next animation frame
	ld a,(hl)					; 
	inc a						; 
	and $1						; limit to two animations: %00 and %01
	ld (hl),a					; save the new value

	ld hl,main_loop				;
	push hl						; load main_loop onto the stack so that ret jumps there

	ld a,$FE					; group 1
	call get_key				; check arrow keys
	rrca						; down
	push af						; since we return from the call, we need to preserve a
		call nc,walk_down
	pop af
	rrca
	push af
		call nc,walk_left
	pop af
	rrca
	push af
		call nc,walk_right
	pop af
	rrca
	 call nc,walk_up
	cp $FF						; if a key was pressed we don't need to reset the animation
	 ret nz
	ld (walk_anim),a			; if no key was pressed, reset player's animation ($FF)
	ret

;###########################
;# force_down, force_up, etc. are used
;# .. to skip tile checking. convenient 
;# .. for use in events, eg. tiles
;# .. that activate when you step on them
;###########################

;###########################
player_walk:
;# This moves the player based on the
;# .. direction they're facing.
;# .. Useful for events or perhaps
;# .. even cutscenes?!
;# Inputs:
;# -none (reads value in player_direction)
;###########################
	ld a,(player_direction)
	or a
	 jr z,force_down
	dec a
	 jp z,force_left
	dec a
	 jp z,force_right
	jp force_up


;###########################
walk_down:
;###########################
	xor a
	ld (player_direction),a
	ld bc,$0100					; y offset = +1
	call get_player_map
	ld a,(hl)					; a = tile id
	call check_tile				; check if tile can be passed, events, etc.
	 ret nz						; if nz, then we can't move there
force_down:
	ld a,(player_y)				; check how far down the screen the player is
	ld hl,map_y					; .. once you reach a certain point, the screen scrolls
	sub (hl)					; .. instead of the player
	cp 4
	 jr nc,scroll_down
walk_down_player:
	ld b,8
walk_down_loop:
	push bc
		ld hl,player_y_off
		inc (hl)
		call draw_map
		call draw_player
		call fastCopy
	pop bc
	djnz walk_down_loop
	ld hl,player_y_off
	ld (hl),b
	ld hl,player_y
	inc (hl)
	ret
scroll_down:
	ld a,(mapHeight)			; check if map has reached the edge
	ld hl,map_y					; .. if so, continue moving the player
	sub (hl)					; .. instead of the map
	cp 8
	 jr z,walk_down_player
	ld hl,(mapWidth)			; we need to load the row below the map
	ld h,0
	add hl,hl					; .. so we need to multiply mapWidth by 8
	add hl,hl
	add hl,hl
	push hl
		call get_map_offset
	pop de
	add hl,de					; hl now points to the first tile beneath the screen
	ld b,12						; there are 12 columns of tiles
	ld de,scrollBuf				; where to load sprites to
sd_new_row:
	push bc						; save counter
		push hl					; save map location
			push de				; save scrollBuf location
				ld l,(hl)		; get tile id
				call get_tile	; hl = tile data
			pop de
			ld bc,8				; copy sprite data to scrollBuf
			ldir
		pop hl					; move to next byte in map
		inc hl
	pop bc						; repeat 8 times
	djnz sd_new_row

	ld b,8
	exx
		ld hl,scrollBuf			; fill in the bottom row of pixels
	exx
scroll_down_loop:
	push bc
		ld de,gbuf				; shift the gbuf up
		ld hl,gbuf+12			; 
		ld bc,756				; 756 bytes to shift (63 rows of 12 bytes each)
		ldir
		ld b,12					; copy 12 bytes from scrollBuf
		exx
			push hl				; save scrollBuf position
			ld de,8
		exx
sd_fill_row:
		exx
			ld a,(hl)			; load byte from scrollBuf
			add hl,de			; move to next sprite in scrollBuf
		exx
		ld (de),a
		inc de
		djnz sd_fill_row
		call draw_player
		call fastCopy
		call clear_player
		exx
			pop hl				; recall original scrollBuf position
			inc hl				; and move to next row of sprite data
		exx
	pop bc
	djnz scroll_down_loop
	ld hl,player_y
	inc (hl)
	ld hl,map_y
	inc (hl)
	ret

;###########################
walk_up:
;###########################
	ld a,PLAYER_UP
	ld (player_direction),a
	ld bc,$FF00					; y offset = -1
	call get_player_map			; b holds the offset to add to player's position
	ld a,(hl)					; a holds tile id
	call check_tile				; essentially a cpir of passable tiles
	 ret nz						; if nz, then we can't move there
force_up:
	ld a,(player_y)
	ld hl,map_y
	sub (hl)
	cp 4
	 jr c,scroll_up
walk_up_player:
	ld b,7
	ld hl,player_y
	dec (hl)
	ld hl,player_y_off
	ld (hl),b
walk_up_loop:
	push bc
		ld hl,player_y_off
		dec (hl)
		call draw_map
		call draw_player
		call fastCopy
	pop bc
	djnz walk_up_loop
	ret
scroll_up:
	ld a,(map_y)
	or a
	 jr z,walk_up_player
	call get_map_offset
	ld de,(mapWidth)			; we need to load the row above the map
	ld d,0
	sbc hl,de					; hl now points to the first tile above the screen
	ld b,12						; there are 12 columns of tiles
	ld de,scrollBuf				; where to load sprites to
su_new_row:
	push bc						; save counter
		push hl					; save map location
			push de				; save scrollBuf location
				ld l,(hl)		; get tile id
				call get_tile	; hl = tile data
			pop de
			ld bc,8				; copy sprite data to scrollBuf
			ldir
		pop hl					; move to next byte in map
		inc hl
	pop bc						; repeat 8 times
	djnz su_new_row

	ld b,8
	exx
		ld hl,scrollBuf+(8*12)-1	; fill in the bottom row of pixels
	exx
scroll_up_loop:
	push bc
		ld hl,gbuf+756-1		; 
		ld de,gbuf+768-1		; shift the gbuf down
		ld bc,756				; 756 bytes to shift (63 rows of 12 bytes each)
		lddr
		ld b,12					; copy 12 bytes from scrollBuf
		exx
			push hl				; save scrollBuf position
			ld de,-8
		exx
su_fill_row:
		exx
			ld a,(hl)			; load byte from scrollBuf
			add hl,de			; move to next sprite in scrollBuf
		exx
		ld (de),a
		dec de
		djnz su_fill_row
		call draw_player
		call fastCopy
		call clear_player
		exx
			pop hl				; recall original scrollBuf position
			dec hl				; and move to next row of sprite data
		exx
	pop bc
	djnz scroll_up_loop
	ld hl,player_y
	dec (hl)
	ld hl,map_y
	dec (hl)
	ret

;###########################
walk_left:
;###########################
	ld a,PLAYER_LEFT
	ld (player_direction),a
	ld bc,$00FF					; x offset = -1
	call get_player_map			; c holds the offset to add to player's x position
	ld a,(hl)					; a holds tile id
	call check_tile				; essentially a cpir of passable tiles
	 ret nz						; if nz, then we can't move there
force_left:
	ld a,(player_x)
	ld hl,map_x
	sub (hl)
	cp 6
	 jr c,scroll_left
walk_left_player:
	ld b,7
	ld hl,player_x
	dec (hl)
	ld hl,player_x_off
	ld (hl),b
walk_left_loop:
	push bc
		ld hl,player_x_off
		dec (hl)
		call draw_map
		call draw_player
		call fastCopy
	pop bc
	djnz walk_left_loop
	ret
scroll_left:
	ld a,(map_x)
	or a
	 jr z,walk_left_player
	call get_map_offset
	dec hl
	ld b,8						; there are 8 rows of tiles
	ld de,scrollBuf				; where to load sprites to
sl_new_column:
	push bc
		push hl
			push de
				ld l,(hl)		; get tile id
				call get_tile	; hl = tile data
			pop de
			ld bc,8
			ldir
		pop hl
		ld bc,(mapWidth)
		ld b,0
		add hl,bc
	pop bc
	djnz sl_new_column

	ld b,8
scroll_left_out:
	push bc
		ld b,64
		ld hl,gbuf
		ld de,scrollBuf
scroll_left_in:
		ex de,hl
			rr (hl)				; put new sprite data into the carry
			inc hl
		ex de,hl
		rr (hl) \ inc hl		; 1
		rr (hl) \ inc hl
		rr (hl) \ inc hl
		rr (hl) \ inc hl
		rr (hl) \ inc hl
		rr (hl) \ inc hl
		rr (hl) \ inc hl
		rr (hl) \ inc hl
		rr (hl) \ inc hl
		rr (hl) \ inc hl
		rr (hl) \ inc hl
		rr (hl) \ inc hl
		djnz scroll_left_in	
		call draw_player
		call fastCopy
		call clear_player
	pop bc
	djnz scroll_left_out
	ld hl,player_x
	dec (hl)
	ld hl,map_x
	dec (hl)
	ret

;###########################
walk_right:
;###########################
	ld a,PLAYER_RIGHT
	ld (player_direction),a
	ld bc,$0001					; x offset = 1
	call get_player_map			; c holds the offset to add to player's x position
	ld a,(hl)					; a holds tile id
	call check_tile				; essentially a cpir of passable tiles
	 ret nz						; if nz, then we can't move there
force_right:
	ld a,(player_x)
	ld hl,map_x
	sub (hl)
	cp 6
	 jr nc,scroll_right
walk_right_player:
	ld b,7
walk_right_loop:
	push bc
		ld hl,player_x_off
		inc (hl)
		call draw_map
		call draw_player
		call fastCopy
	pop bc
	djnz walk_right_loop
	ld hl,player_x_off
	ld (hl),b
	ld hl,player_x
	inc (hl)
	ret
scroll_right:
	call get_map_offset
	ld de,12					; we need to load the tile to the right of the screen
	add hl,de
	ld b,8						; there are 8 rows of tiles
	ld de,scrollBuf				; where to load sprites to
sr_new_column:
	push bc
		push hl
			push de
				ld l,(hl)		; get tile id
				call get_tile	; hl = tile data
			pop de
			ld bc,8
			ldir
		pop hl
		ld bc,(mapWidth)
		ld b,0
		add hl,bc
	pop bc
	djnz sr_new_column
	ld b,8
scroll_right_out:
	push bc
		ld b,64
		ld hl,gbuf+768-1
		ld de,scrollBuf+(8*8)-1
scroll_right_in:
		ex de,hl
			rl (hl)				; put new sprite data into the carry
			dec hl
		ex de,hl
		rl (hl) \ dec hl		; 1
		rl (hl) \ dec hl
		rl (hl) \ dec hl
		rl (hl) \ dec hl
		rl (hl) \ dec hl
		rl (hl) \ dec hl
		rl (hl) \ dec hl
		rl (hl) \ dec hl
		rl (hl) \ dec hl
		rl (hl) \ dec hl
		rl (hl) \ dec hl
		rl (hl) \ dec hl		; 12
		djnz scroll_right_in
		call draw_player
		call fastCopy
		call clear_player
	pop bc
	djnz scroll_right_out
	ld hl,player_x
	inc (hl)
	ld hl,map_x
	inc (hl)
	ret

#include "menu.inc"
#include "new.inc"
#include "engine.inc"
#include "events.inc"
#include "trainers.inc"
#include "battle.inc"
#include "battle_graphics.inc"
#include "ai.inc"
#include "routines.inc"
#include "maths.inc"
#include "stats.inc"
#include "attacks.inc"
#include "types.inc"
#include "strings.inc"
#ifdef FR
	; il faudra sans doute que je rajoute les fichiers types.inc et pokemons.inc qui sont en partie en français !!!
	.echo "Compiling in french."
	#include "strings_fr.inc"
#else
#ifdef EN
	.echo "Compiling in english."
	#include "strings_en.inc"
#else
	.echo "Error: no language selected."
	.echo "Using default French files."
	#include "strings_fr.inc"
#endif
#endif
#include "sprites.inc"
#include "tiles.inc"
#include "maps.inc"
#include "pokemons.inc"
.echo "Current size: ",$-$4000," bytes."
	.end
